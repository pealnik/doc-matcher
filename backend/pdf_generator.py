"""
PDF Report Generator for Compliance Results

This module uses reportlab to generate professional-looking PDF reports
from the compliance check results. It includes a modern design with
headers, footers, and a clear layout for summarizing and detailing the findings.
"""

import io
from datetime import datetime
from reportlab.platypus import (
    BaseDocTemplate, Frame, Paragraph, Spacer, PageTemplate, Table, TableStyle
)
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.pagesizes import A4
from reportlab.lib.units import inch
from reportlab.lib import colors
from reportlab.lib.enums import TA_LEFT
from pathlib import Path
import argparse
import os
import sys
import logging

def _header(canvas, doc):
    """Adds a header to each page."""
    canvas.saveState()
    canvas.setFont('Helvetica', 9)
    canvas.setFillColor(colors.HexColor('#6b7280'))
    header_title = getattr(doc, 'report_title', 'IHM Compliance Report')
    canvas.drawString(doc.leftMargin, doc.height + doc.topMargin + 0.5 * inch, header_title)
    canvas.drawRightString(doc.width + doc.leftMargin, doc.height + doc.topMargin + 0.5 * inch, f"Page {doc.page}")
    canvas.restoreState()

def _footer(canvas, doc):
    """Adds a footer to each page."""
    canvas.saveState()
    canvas.setFont('Helvetica', 8)
    canvas.setFillColor(colors.HexColor('#6b7280'))
    footer_text = f"Generated by PDF Compliance Checker â€¢ {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
    canvas.drawCentredString(doc.width / 2 + doc.leftMargin, 0.5 * inch, footer_text)
    canvas.restoreState()

def get_status_colors(status: str):
    """Returns background and text color based on compliance status."""
    if status == "Compliant":
        return colors.HexColor('#d1fae5'), colors.HexColor('#065f46')
    if status == "Non-Compliant":
        return colors.HexColor('#fee2e2'), colors.HexColor('#991b1b')
    if status == "Partially Compliant":
        return colors.HexColor('#ffedd5'), colors.HexColor('#9a3412')
    return colors.white, colors.black

def generate_compliance_pdf(task_data: dict) -> io.BytesIO:
    """
    Generates a professional, Shopify-style PDF report from compliance check results.
    """
    buffer = io.BytesIO()

    # Document setup
    doc = BaseDocTemplate(buffer, pagesize=A4, # Changed from landscape(A4) to A4
                          leftMargin=0.75*inch, rightMargin=0.75*inch,
                          topMargin=1*inch, bottomMargin=0.75*inch) # Reduced margins slightly

    # Add page templates for header and footer
    frame = Frame(doc.leftMargin, doc.bottomMargin, doc.width, doc.height, id='normal')
    template = PageTemplate(id='main_template', frames=[frame], onPage=_header, onPageEnd=_footer)
    doc.addPageTemplates([template])

    styles = getSampleStyleSheet()
    styles.add(ParagraphStyle(name='ReportTitle', fontSize=20, fontName='Helvetica-Bold', alignment=TA_LEFT, spaceAfter=8)) # Reduced font size and spacing
    styles.add(ParagraphStyle(name='ReportSubtitle', fontSize=10, fontName='Helvetica', alignment=TA_LEFT, textColor=colors.HexColor('#4b5563'), spaceAfter=0.1 * inch)) # Reduced font size and spacing
    styles.add(ParagraphStyle(name='SectionHeader', fontSize=14, fontName='Helvetica-Bold', alignment=TA_LEFT, spaceBefore=15, spaceAfter=8)) # Reduced font size and spacing
    styles.add(ParagraphStyle(name='SmallNormal', parent=styles['Normal'], fontSize=8, leading=9)) # Adjusted font size and leading
    styles.add(ParagraphStyle(name='SmallBold', parent=styles['SmallNormal'], fontName='Helvetica-Bold'))

    story = []

    # --- Title and Metadata ---
    title = task_data.get("output_report_title") or "IHM Compliance Report"
    # Make title available to page templates (header)
    setattr(doc, 'report_title', title)
    story.append(Paragraph(title, styles['ReportTitle']))
    # Increase space between document title and the first metadata line (filename)
    story.append(Spacer(1, 0.25 * inch))

    result_data = task_data.get("result", {})
    summary = result_data.get("summary", {})
    gen_date = datetime.fromisoformat(task_data["created_at"]).strftime("%B %d, %Y")
    # Use single <br/>s to reduce vertical gaps between meta lines
    meta_data = f"""
        <b>Report File:</b> {task_data.get("report_filename", "N/A")}<br/>
        <b>Generated:</b> {gen_date}<br/>
        <b>Total Checks:</b> {summary.get("total", 0)}<br/>
        <b>Total Pages:</b> {summary.get("total_pages", 0)}
    """
    # Slightly smaller space after metadata to tighten the top section
    story.append(Paragraph(meta_data, styles['ReportSubtitle']))
    story.append(Spacer(1, 0.08 * inch))

    # --- Summary Section (Condensed) ---
    # Removed: story.append(Paragraph("Summary", styles['SectionHeader']))
    
    summary_data = [
        [
            Paragraph('<b>Compliant</b>', styles['SmallNormal']),
            Paragraph('<b>Non-Compliant</b>', styles['SmallNormal']),
            Paragraph('<b>Partially Compliant</b>', styles['SmallNormal']),
        ],
        [
            str(summary.get("compliant", 0)),
            str(summary.get("non_compliant", 0)),
            str(summary.get("partially_compliant", 0)),
        ]
    ]
    
    summary_table = Table(summary_data, colWidths=[1.5*inch, 1.5*inch, 1.5*inch]) # Adjusted colWidths
    summary_table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#f9fafb')), # Header background
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.HexColor('#1f2937')), # Header text color
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, 0), 8), # Header font size
        ('BOTTOMPADDING', (0, 0), (-1, 0), 6),
        ('TOPPADDING', (0, 0), (-1, 0), 6),
        ('FONTNAME', (0, 1), (-1, 1), 'Helvetica'),
        ('FONTSIZE', (0, 1), (-1, 1), 8), # Data font size
        ('BOTTOMPADDING', (0, 1), (-1, 1), 6),
        ('TOPPADDING', (0, 1), (-1, 1), 6),
        ('GRID', (0, 0), (-1, -1), 0.5, colors.HexColor('#e5e7eb')),
        ('BOX', (0, 0), (-1, -1), 0.5, colors.HexColor('#e5e7eb')),
    ]))
    story.append(summary_table)
    story.append(Spacer(1, 0.2 * inch))

    # --- Detailed Results Table ---
    story.append(Paragraph("Detailed Compliance Results", styles['SectionHeader']))

    rows = result_data.get("rows", [])
    if not rows:
        story.append(Paragraph("No compliance data available.", styles['Normal']))
    else:
        table_header = [
            Paragraph('<b>Requirement ID / Reference</b>', styles['SmallNormal']),
            Paragraph('<b>Requirement Text / Evidence</b>', styles['SmallNormal']),
            Paragraph('<b>Status</b>', styles['SmallNormal']),
            Paragraph('<b>Remarks</b>', styles['SmallNormal']),
        ]
        table_data = [table_header]
        
        table_styles = [
            ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#f9fafb')),
            ('VALIGN', (0, 0), (-1, -1), 'TOP'),
            ('LINEBELOW', (0, 0), (-1, 0), 2, colors.HexColor('#e5e7eb')),
            ('TOPPADDING', (0, 0), (-1, -1), 6), # Reduced padding
            ('BOTTOMPADDING', (0, 0), (-1, -1), 6), # Reduced padding
            ('INNERGRID', (0, 0), (-1, -1), 0.25, colors.HexColor('#e5e7eb')), # Added inner grid for better structure
            ('BOX', (0, 0), (-1, -1), 0.5, colors.HexColor('#e5e7eb')), # Added outer box
        ]

        # Calculate dynamic column widths to fit A4 portrait
        # Total available width = 6.77 inches. Distribute it.
        col_widths = [1.3*inch, 2.7*inch, 1.0*inch, 1.7*inch] # Sums to 6.7 inch

        for i, row_data in enumerate(rows, start=1):
            status = row_data.get("status", "Unknown")
            bg_color, text_color = get_status_colors(status)

            # Create styled paragraphs for each cell
            # Build requirement ID/reference cell
            req_id = row_data.get("requirement_id") or row_data.get("mepc_reference") or "N/A"
            reg_source = row_data.get("regulation_source", "")
            req_id_text = f"<b>{req_id}</b>"

            req_id_cell = Paragraph(req_id_text, styles['SmallNormal'])
            requirement_text = row_data.get("requirement_text") or row_data.get("ihm_output") or row_data.get("evidence") or "N/A"
            requirement_cell = Paragraph(requirement_text, styles['SmallNormal'])
            status_cell = Paragraph(f'<b>{status}</b>',
                ParagraphStyle('Status', parent=styles['SmallNormal'], backColor=bg_color, textColor=text_color, borderRadius=3, padding=3) # Reduced padding
            )
            remarks = Paragraph(row_data.get("remarks", "N/A"), styles['SmallNormal'])

            table_data.append([req_id_cell, requirement_cell, status_cell, remarks])
            
            # Add alternating row background colors
            if i % 2 == 0:
                table_styles.append(('BACKGROUND', (0, i), (-1, i), colors.HexColor('#f9fafb')))
            else:
                table_styles.append(('BACKGROUND', (0, i), (-1, i), colors.white))

        results_table = Table(table_data, colWidths=col_widths, repeatRows=1)
        results_table.setStyle(TableStyle(table_styles))
        story.append(results_table)

    doc.build(story)
    buffer.seek(0)
    return buffer


def _cli_main(argv: list[str] | None = None) -> int:
    """Simple CLI to regenerate a PDF from a saved result JSON file.

    Usage examples:
      python backend/pdf_generator.py --input backend/results/<task_id>.json --output compliance_<task_id>.pdf
      python backend/pdf_generator.py -i backend/results/<task_id>.json --title "My Title"
    """
    parser = argparse.ArgumentParser(prog="generate_compliance_pdf",
                                     description="Generate compliance PDF from result JSON")
    parser.add_argument("-i", "--input", required=True, help="Path to the result JSON file (as saved in results/)")
    parser.add_argument("-o", "--output", required=False, help="Output PDF path (defaults to input basename with .pdf)")
    parser.add_argument("-t", "--title", required=False, help="Override the report title (default: use output_report_title in JSON or IHM Compliance Report)")
    parser.add_argument("-f", "--force", action="store_true", help="Overwrite output file if it exists")

    args = parser.parse_args(argv)

    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

    input_path = args.input
    if not os.path.exists(input_path):
        logging.error("Input file does not exist: %s", input_path)
        return 2

    try:
        import json
        with open(input_path, 'r', encoding='utf-8') as f:
            task_data = json.load(f)
    except Exception as e:
        logging.error("Failed to read input JSON: %s", e)
        return 3

    # Normalize different saved result file shapes to the internal `task_data` shape
    # Some saved files use top-level `results` (list) and `completed_at`; normalize
    if "result" not in task_data and "results" in task_data:
        original_output_report_title = task_data.get("output_report_title") # Preserve output_report_title
        rows = task_data.get("results", [])
        summary = task_data.get("summary", {})
        created = task_data.get("created_at") or task_data.get("completed_at") or datetime.now().isoformat()
        task_data = {
            "report_filename": task_data.get("report_filename", "N/A"),
            "created_at": created,
            "result": {
                "rows": rows,
                "summary": summary
            },
        }
        if original_output_report_title: # Re-add if it existed
            task_data["output_report_title"] = original_output_report_title
    out_path = args.output
    if not out_path:
        base = os.path.splitext(os.path.basename(input_path))[0]
        # Default to backend/output_reports to keep generated PDFs inside the project
        output_dir = Path(__file__).parent / "output_reports"
        output_dir.mkdir(parents=True, exist_ok=True)
        out_path = str(output_dir / f"compliance_{base}.pdf")

    if os.path.exists(out_path) and not args.force:
        logging.error("Output file already exists: %s (use --force to overwrite)", out_path)
        return 4

    # Compute title precedence: CLI override -> output_report_title from JSON -> default handled by generator
    report_title = args.title or task_data.get("output_report_title")

    try:
        # If the user passed an explicit title, inject it into the task data so the
        # existing generator code (which looks for `output_report_title`) will use it.
        if report_title:
            task_data["output_report_title"] = report_title
        buf = generate_compliance_pdf(task_data)
        with open(out_path, 'wb') as out_f:
            out_f.write(buf.getvalue())
        logging.info("Wrote PDF: %s", out_path)
        return 0
    except Exception as e:
        logging.exception("Failed to generate PDF: %s", e)
        return 5


if __name__ == '__main__':
    raise SystemExit(_cli_main())
